#- * - coding: utf - 8 - *-

from main import bert_func0

text = '    ПРЕДПЛУЖНИКИ И УГЛОСНИМЫ выполняют схожую задачу – «срезая» верхний слой почвы направляют его на дно борозды  Это особенно актуально  когда необходимо создать чистый фон без пожнивных остатков и камней на поверхности  В зависимости от условий работы эффективность  применения предплужников и углоснимов может отличаться  Причина – различие в конструкции и способе установки на плуге     «За счёт сброса верхнего слоя вниз борозды сорняки  корни  семена   накопленные за летний период  окажутся погребены максимально глубоко  Семена сорняков с такой глубины уже не взойдут »«За счёт лучшей заделки растительных остатков предшественника уменьшается инфицированный фон по болезням под следующую культуру  особенно листовым как септориоз  гельминтоспориоз  ржавчина а также болезней колоса     »            ПРЕДПЛУЖНИК   По конструкции предплужник больше похож на полноценный корпус с отвалом и лемехом  но меньшего размера чем основные корпуса плуга  Имеет следующие особенности   ✅Устанавливается перед основным корпусом  а следовательно уменьшает просвет между стойками плуга  Это приводит к меньшей проходимости по неизмельченным растительным остаткам    ✅Устанавливается на отдельной стойке – имеет регулировку глубины работы  Рекомендуемая настройка глубины – 5 7см   ✅Срезает угол пласта почвы  который в отсутствие предплужника при обороте оказывается ближе к поверхности – позволяет создать более чистый фон     «Для предплужника же нужны лучше условия  если много крупных растительных остатков может потребоваться дискование перед вспашкой или работа мульчировщика  »    «Единственный существенный плюс от предплужника можно считать лучшее крошение почвы  по сравнению с углоснимом »  Совет  Для более эффективного применения предплужников по большому количеству растительных неизмельченных остатков лучше установить на каждый корпус дисковые ножи или килевидные ножи на полевую доску  Это поможет снизить нагрузку на трактор и повысить качество оборота пласта         УГЛОСНИМ   Представляет собой полосовой узкий отвал который устанавливается над основным отвалом  Имеет следующие характеристики   ✅Простая конструкция   стоимость такой опции ниже опции предплужников   ✅Установка на корпусе – не имеет регулировки и возможности настройки  При использовании отвалов для глубокой работы  при поверхностной пахоте пласт почвы может не доходить до углоснима   ✅Работает по всей поверхности  без заглубления – эффективно сбрасывает камни на дно борозды  но уступает предплужнику в качестве заделки растительных остатков     «По стоимости и металлоёмкости выигрывает углосним  Он не требует установки стойки  так как крепится прямо к отвалу корпуса  Это даёт ему ещё одно существенное преимущество   плуг с углоснимом меньше забивается  так как просвет между корпусами ничем не закрыт  предплужниками  »«Дополнительные углоснимы и предплужники в хозяйстве  считаю  нужно иметь хотя бы по одному на агрегате  так как в поле бывают разные ситуации »            РЕЗЮМЕ   И предплужники  и углоснимы могут эффективно работать в одних и тех же условиях  Но первые лучше подойдут для заделки большого количества пожнивных остатков  к примеру  после кукурузы на зерно  а вторые – для работы на каменистых почвах  В сравнении со стоимостью плуга цена на эти опции не значительна  поэтому  по возможности  лучше заказывать обе эти опции  Так вы сможете более гибко применять плуг в разных условиях и получать максимально возможное качество вспашки А какой у вас опыт работы с углоснимами и предплужниками '

a = bert_func0(text)

# def bert_func0(text):
#
#     #text = '    ПРЕДПЛУЖНИКИ И УГЛОСНИМЫ выполняют схожую задачу – «срезая» верхний слой почвы направляют его на дно борозды  Это особенно актуально  когда необходимо создать чистый фон без пожнивных остатков и камней на поверхности  В зависимости от условий работы эффективность  применения предплужников и углоснимов может отличаться  Причина – различие в конструкции и способе установки на плуге     «За счёт сброса верхнего слоя вниз борозды сорняки  корни  семена   накопленные за летний период  окажутся погребены максимально глубоко  Семена сорняков с такой глубины уже не взойдут »«За счёт лучшей заделки растительных остатков предшественника уменьшается инфицированный фон по болезням под следующую культуру  особенно листовым как септориоз  гельминтоспориоз  ржавчина а также болезней колоса     »            ПРЕДПЛУЖНИК   По конструкции предплужник больше похож на полноценный корпус с отвалом и лемехом  но меньшего размера чем основные корпуса плуга  Имеет следующие особенности   ✅Устанавливается перед основным корпусом  а следовательно уменьшает просвет между стойками плуга  Это приводит к меньшей проходимости по неизмельченным растительным остаткам    ✅Устанавливается на отдельной стойке – имеет регулировку глубины работы  Рекомендуемая настройка глубины – 5 7см   ✅Срезает угол пласта почвы  который в отсутствие предплужника при обороте оказывается ближе к поверхности – позволяет создать более чистый фон     «Для предплужника же нужны лучше условия  если много крупных растительных остатков может потребоваться дискование перед вспашкой или работа мульчировщика  »    «Единственный существенный плюс от предплужника можно считать лучшее крошение почвы  по сравнению с углоснимом »  Совет  Для более эффективного применения предплужников по большому количеству растительных неизмельченных остатков лучше установить на каждый корпус дисковые ножи или килевидные ножи на полевую доску  Это поможет снизить нагрузку на трактор и повысить качество оборота пласта         УГЛОСНИМ   Представляет собой полосовой узкий отвал который устанавливается над основным отвалом  Имеет следующие характеристики   ✅Простая конструкция   стоимость такой опции ниже опции предплужников   ✅Установка на корпусе – не имеет регулировки и возможности настройки  При использовании отвалов для глубокой работы  при поверхностной пахоте пласт почвы может не доходить до углоснима   ✅Работает по всей поверхности  без заглубления – эффективно сбрасывает камни на дно борозды  но уступает предплужнику в качестве заделки растительных остатков     «По стоимости и металлоёмкости выигрывает углосним  Он не требует установки стойки  так как крепится прямо к отвалу корпуса  Это даёт ему ещё одно существенное преимущество   плуг с углоснимом меньше забивается  так как просвет между корпусами ничем не закрыт  предплужниками  »«Дополнительные углоснимы и предплужники в хозяйстве  считаю  нужно иметь хотя бы по одному на агрегате  так как в поле бывают разные ситуации »            РЕЗЮМЕ   И предплужники  и углоснимы могут эффективно работать в одних и тех же условиях  Но первые лучше подойдут для заделки большого количества пожнивных остатков  к примеру  после кукурузы на зерно  а вторые – для работы на каменистых почвах  В сравнении со стоимостью плуга цена на эти опции не значительна  поэтому  по возможности  лучше заказывать обе эти опции  Так вы сможете более гибко применять плуг в разных условиях и получать максимально возможное качество вспашки А какой у вас опыт работы с углоснимами и предплужниками '
#
#     """# Main"""
#
#     import torch
#
#     device = torch.device("cpu")
#
#     # Importing stock ml libraries
#     import numpy as np
#     import pandas as pd
#     from sklearn import metrics
#     from sklearn.model_selection import train_test_split
#
#     import transformers
#     import torch
#     from torch.utils.data import Dataset, DataLoader, RandomSampler, SequentialSampler
#     from transformers import BertTokenizer, BertModel, BertConfig
#
#     import nltk
#
#     from nltk.corpus import stopwords
#     from string import punctuation
#     import pymorphy2
#
#     russian_stopwords = stopwords.words("russian")
#     morph = pymorphy2.MorphAnalyzer()
#
#     def preprocess_text(text):
#
#         tokens = text.split()
#         res = []
#
#         for token in tokens:
#           if ((token.lower() not in russian_stopwords) and (token != " ") and (token.strip() not in punctuation)):
#             res.append(token)
#
#         text = " ".join(res).replace("????","")
#
#         return text
#
#     # Sections of config
#
#     # Defining some key variables that will be used later on in the training
#     MAX_LEN = 256
#     VALID_BATCH_SIZE = 16
#     CLASS_COUNT = 6
#     tokenizer = BertTokenizer.from_pretrained('DeepPavlov/rubert-base-cased')
#     #print(tokenizer)
#
#     class CustomDataset(Dataset):
#
#         def __init__(self, dataframe, tokenizer, max_len):
#             self.tokenizer = tokenizer
#             self.data = dataframe
#             self.title = dataframe['text']
#             self.targets = self.data.target_list
#             self.max_len = max_len
#
#         def __len__(self):
#             return len(self.title)
#
#         def __getitem__(self, index):
#             title = str(self.title[index])
#             title = " ".join(title.split())
#
#             inputs = self.tokenizer.encode_plus(
#                 title,
#                 None,
#                 add_special_tokens=True,
#                 max_length=self.max_len,
#                 padding='max_length',
#                 return_token_type_ids=True,
#                 truncation=True
#             )
#             ids = inputs['input_ids']
#             mask = inputs['attention_mask']
#             token_type_ids = inputs["token_type_ids"]
#
#
#             return {
#                 'ids': torch.tensor(ids, dtype=torch.long),
#                 'mask': torch.tensor(mask, dtype=torch.long),
#                 'token_type_ids': torch.tensor(token_type_ids, dtype=torch.long),
#                 'targets': torch.tensor(self.targets[index], dtype=torch.float)
#             }
#
#     class BERTClass(torch.nn.Module):
#         def __init__(self):
#             super(BERTClass, self).__init__()
#             self.l1 = transformers.BertModel.from_pretrained('DeepPavlov/rubert-base-cased')
#             self.l2 = torch.nn.Dropout(0.3)
#             self.l3 = torch.nn.Linear(768, CLASS_COUNT)
#
#         def forward(self, ids, mask, token_type_ids):
#             _, output_1= self.l1(ids, attention_mask = mask, token_type_ids = token_type_ids)
#             output_2 = self.l2(output_1)
#             output = self.l3(output_2)
#             return output
#
#     model = BERTClass()
#     model.to(device)
#
#     checkpoint_path = 'D:/Files/Pycharm_Pr/checkpoint/current_checkpoint.pt'
#     best_model = 'D:/Files/Pycharm_Pr/best_model/best_model.pt'
#
#     my_model = 'D:/Files/Pycharm_Pr/best_model/my_model.pt'
#     model.load_state_dict(torch.load(my_model, map_location=torch.device('cpu')), strict=False) # path of your weights
#     model.eval()
#
#     from sklearn.metrics import multilabel_confusion_matrix as mcm, classification_report
#
#     test_targets = []
#     test_outputs = []
#
#     def test_model(test_loader, model):
#       with torch.no_grad():
#           for batch_idx, data in enumerate(test_loader, 0):
#                 ids = data['ids'].to(device, dtype = torch.long)
#                 mask = data['mask'].to(device, dtype = torch.long)
#                 token_type_ids = data['token_type_ids'].to(device, dtype = torch.long)
#                 targets = data['targets'].to(device, dtype = torch.float)
#                 outputs = model(ids, mask, token_type_ids)
#                 #print(outputs)
#
#                 #print(batch_idx)
#
#                 test_targets.extend(targets.cpu().detach().numpy().tolist())
#                 test_outputs.extend(torch.sigmoid(outputs).cpu().detach().numpy().tolist())
#                 #print(test_targets)
#                 #print(test_outputs)
#
#
#     #test_model(test_loader, model)
#
#     test_params = {'batch_size': VALID_BATCH_SIZE,
#                     'shuffle': False,
#                     'num_workers': 0
#                     }
#
#     """# Test"""
#
#     # raw_data_path = '/content/drive/MyDrive/DirectFarmPostClassification/8.csv'
#
#     # df_raw =  pd.read_csv(raw_data_path, sep=";")
#
#     # df_raw.head()
#     # #print(df_raw.__dict__)
#
#     df_test = pd.DataFrame([[0, 1, 1, 1, 1, 1, 1, text],
#                             ],
#     columns=['id','Животноводство', 'агрономия', 'Растениеводство',
#            'Помощь животновода', 'сельхозтехника', 'агротехника', 'text'])
#
#
#     #print(df_test.__dict__)
#     df_raw = df_test
#     df_test.head()
#
#     df_raw['text'] = df_raw['text'].map(lambda x: preprocess_text(str(x)))
#     df_raw.head()
#
#     df_raw.columns
#
#     df_raw['target_list'] = df_raw[['Животноводство', 'агрономия', 'Растениеводство', 'Помощь животновода', 'сельхозтехника', 'агротехника']].values.tolist()
#     categ = ['Животноводство', 'агрономия', 'Растениеводство', 'Помощь животновода', 'сельхозтехника', 'агротехника']
#
#     df_raw = df_raw[df_raw['target_list'].map(lambda x: 1 in x)]
#     df_raw.shape
#
#     df_raw.head()
#
#     df_raw['WORD_COUNT'] = df_raw['text'].apply(lambda x: len(str(x).split()))
#
#     df_raw.sum()
#
#     df2 = df_raw[['text', 'target_list']].copy()
#     df2.head()
#     #print(df2.__dict__)
#     #df2.columns.tolist()
#
#     test_targets = []
#     test_outputs = []
#
#     df2 = df_raw[['text', 'target_list']].copy()
#     #print(df2)
#     train_size = 1
#     df2 = df2.sample(frac=train_size,random_state=200)
#     #print(df2)
#     df2 = df2.reset_index(drop=True)
#     #print(df2)
#     df2 = CustomDataset(df2, tokenizer, MAX_LEN)
#     df2 = DataLoader(df2, **test_params)
#     #print(df2.__dict__)
#     df2 = test_model(df2, model)
#     #print(test_targets)
#     #print(test_preds)
#     #print(test_outputs)
#     #print(df2)
#     #print(test_loader.__dict__)
#
#     test_preds = (np.array(test_outputs) > 0.5).astype(int)
#
#     res = []
#
#     for i in test_outputs:
#         filt = i
#         for j in filt:
#             if j > 0.5:
#                 j = 1
#             else:
#                 j = 0
#             res.append(j)
#
#     res = dict(zip(categ, res))
#
#     return res

# def bert_func1(text):
#
#     text = 'bert_func1'
#
#     return text

# def ru_GPT(text):
#
#     text = 'ru_GPT'
#
#     return text
